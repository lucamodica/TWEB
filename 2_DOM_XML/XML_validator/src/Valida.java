
/*
 * @(#)DomEcho02.java	1.9 98/11/10
 *
 * Copyright 2002 Sun Microsystems, Inc. All Rights Reserved.
 *
 * Redistribution and use in source and binary forms, with or
 * without modification, are permitted provided that the following
 * conditions are met:
 *
 * - Redistributions of source code must retain the above copyright
 *   notice, this list of conditions and the following disclaimer.
 *
 * - Redistribution in binary form must reproduce the above
 *   copyright notice, this list of conditions and the following
 *   disclaimer in the documentation and/or other materials
 *   provided with the distribution.
 *
 * Neither the name of Sun Microsystems, Inc. or the names of
 * contributors may be used to endorse or promote products derived
 * from this software without specific prior written permission.
 *
 * This software is provided "AS IS," without a warranty of any
 * kind. ALL EXPRESS OR IMPLIED CONDITIONS, REPRESENTATIONS AND
 * WARRANTIES, INCLUDING ANY IMPLIED WARRANTY OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT, ARE HEREBY
 * EXCLUDED. SUN AND ITS LICENSORS SHALL NOT BE LIABLE FOR ANY
 * DAMAGES OR LIABILITIES SUFFERED BY LICENSEE AS A RESULT OF OR
 * RELATING TO USE, MODIFICATION OR DISTRIBUTION OF THIS SOFTWARE OR
 * ITS DERIVATIVES. IN NO EVENT WILL SUN OR ITS LICENSORS BE LIABLE
 * FOR ANY LOST REVENUE, PROFIT OR DATA, OR FOR DIRECT, INDIRECT,
 * SPECIAL, CONSEQUENTIAL, INCIDENTAL OR PUNITIVE DAMAGES, HOWEVER
 * CAUSED AND REGARDLESS OF THE THEORY OF LIABILITY, ARISING OUT OF
 * THE USE OF OR INABILITY TO USE THIS SOFTWARE, EVEN IF SUN HAS
 * BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
 *
 * You acknowledge that this software is not designed, licensed or
 * intended for use in the design, construction, operation or
 * maintenance of any nuclear facility.
 *
 */

 /* Questa classe offre la struttura per validare documenti XML
 rispetto a schema, entrambi fissati al momento nel codice
 (modificare la classe per leggerli come parametro durante l'esecuzione).
 Il file po.xml e' valido rispetto a po.xsd, il file poNonValid.xml non lo e'
 e da' errore di parsing.
 NB: la classe usa una versione del parser JAXP che legge le
 grammatiche specificate da XML Schema (classe diversa da quella
 usata per le DTD... vedere nomi delle classi e pacchetti java).
 */

import javax.xml.validation.*;
import javax.xml.XMLConstants;
import javax.xml.transform.*;
import javax.xml.transform.stream.*;
import javax.xml.transform.dom.*;


import javax.xml.parsers.*;

import org.xml.sax.SAXException;
import org.xml.sax.SAXParseException;

import java.io.File;
import java.io.IOException;

import org.w3c.dom.Document;
import org.w3c.dom.DOMException;


import java.util.*;

public class Valida  {
    // Global value so it can be ref'd by the tree-adapter
    static Document document;


    public static void main(String argv[])
    {

  // parse an XML document into a DOM tree
    try {

    DocumentBuilder parser = DocumentBuilderFactory.newInstance().newDocumentBuilder();
	Scanner sc = new Scanner(System.in);
	System.out.println("Inserire il nome del file .xml da analizzare (con estensione): ");
	String xmlDoc = sc.next();
	System.out.println("Inserire il nome del file .xsd da utilizzare per la validazione (con estensione): ");
	String xmlSch = sc.next();
    Document document = parser.parse("es1(XMLSchemas)/" + xmlDoc);

    // create a SchemaFactory capable of understanding WXS schemas
    SchemaFactory factory = SchemaFactory.newInstance(XMLConstants.W3C_XML_SCHEMA_NS_URI);

    // load a WXS schema, represented by a Schema instance
    Source schemaFile = new StreamSource("es1(XMLSchemas)/" + xmlSch);
    Schema schema = factory.newSchema(schemaFile);

    // create a Validator instance, which can be used to validate an instance document
    Validator validator = schema.newValidator();

    System.out.println("Prima della validazione del documento");


    // validate the DOM tree

    validator.validate(new DOMSource(document));

    System.out.println("Dopo la validazione del documento");

    }   catch (SAXParseException spe) {
           // Error generated by the parser
           System.out.println("\n** Parsing error"
              + ", line " + spe.getLineNumber()
              + ", uri " + spe.getSystemId());
           System.out.println("   " + spe.getMessage() );

           // Use the contained exception, if any
           Exception  x = spe;
           if (spe.getException() != null)
               x = spe.getException();
           x.printStackTrace();

        } catch (SAXException sxe) {
           // Error generated during parsing
           Exception  x = sxe;
           System.out.println("Documento non valido");
           if (sxe.getException() != null)
               x = sxe.getException();
           x.printStackTrace();

        } catch (ParserConfigurationException pce) {
            // Parser with specified options can't be built
           pce.printStackTrace();

        } catch (IOException ioe) {
           // I/O error
           ioe.printStackTrace();
        } catch (Exception e) {
		   e.printStackTrace();
		}
    } // main

}
